1.1 서론 
컴퓨터 응용 분야의 종류
-개인 컴퓨터 PC
-서버: 대형 작업 수행에 이용. 신용도를 강조
-수퍼컴퓨터: 프로세서 많고(수십만개), 수 TB의 메모리를 가짐. 일기예보 석유탐사 단백질 구조 결정
-임베디드 컴퓨터: 제일많이 사용. 다른 장치에 포함돼있어서 미리 정해진 한가지, 몇가지 소프트웨어만 실행함. 자동차 마이크로프로세서, 디지털 TV, 프로세서 네트워크 , 사물인터넷 등

임베디드 응용 특징: 최소 성능, 전력 사용량 줄이기


포스트 PC 시대:
-개인 휴대용 기기(Personal mobile device, PMD)
-클라우드 컴퓨팅: 창고 규모 컴퓨팅(warehouse-scale computing, WSC)이라 불리는 거대 규모 데이터 센터를 이용. 인터넷을 통해 서비스를 제공하는 서버들의 집합임.
	-서비스로의 소프트웨어(Software as a Service, SaaS)



1.2 컴퓨터 구조 분야의 주요 7개 아이디어

1, 추상화-설계의 단순화(abstraction): 하위 수준의 상세한 사항을 안보이게 해서 상위 수준 모델을 단순화함.
2. 자주 생기는 일 빠르게(common case fast): 드문 일을 최적화하는 것보다 이게 나음
3. 병렬성-성능 개선(parellism)
4. 파이프라이닝(pipelining): 병렬성의 특별한 형태. 어떤 일을 작은 일들 여러개로 나눈다. 훨씬 빨라진다.
5. 예측(prediction): 결정 될 떄까지 암것도 안하고 기다리는 것보다 뭐라도 하고 잘못되면 뒷수습 하는게 낫다.
6. 메모리 계층 구조(memory hierachy): 빠르고, 크고, 값싼 메모리는 존재하지 않으므로 메모리 계층 구조를 사용해 메모리 효율성을 높임
7. 신용도 개선(여유분을 이용) dependabilaty): 모든 물리 소자는 장애가 발생할 수 있으므로 장애 소자를 대치할 수 있도록 여유분을 준비한다.
(Moore의 법칙은 1년마다 칩에 집적가능한 소자 수가 2배가 된다는 것인데 컴퓨터과학 발전 초기에는 맞는 말이었지만 시간이 지나고 아니게 되었음.)



1.3 프로그램 밑의 세계
:복잡한 응용에서부터 단순 저수준 명령어까지 내려가기. 이때 번역 및 해독하는 여러겹 소프트웨어가 필요하며, 이것은 추상화의 한 예시이다.

<소프트웨어의 계층적 구조>
응용 소프트웨어 - 여러가지 시스템 소프트웨어 - 하드웨어
시스템 소프트웨어의 예: 운영체제(기본 입출력, 보조기억장치와 메모리 할당, 컴퓨터 공유방법 제공 등), 컴파일러(상위 수준 언어 C++같은거를 하드웨어 명령어, 어셈블리어로 단순하게 바꾸는 것), 로더, 어셈블러


<상위 수준 언어에서 기계어까지>
기계어: 이진수(binary digit), 비트 등 기계가 이해하는 언어
어셈블러: 기호로 된 명령어를 이진수로 바꿈 add A, B -> 1001010100101110
어셈블리 언어: 기호형태의 언어에 붙여진 이름

고수준 언어(C, java 등) -> 컴파일러 -> 어셈블러 -> 기계어(이진수)
어셈블러 예시: Fortran(과학 계산), Cobol(업무자료처리), Lisp(기호조작)




1.4 컴퓨터 하드웨어 살펴보기
하드웨어의 기본 기능: (데이터)입력, 출력, 처리, 저장
입력장치: 컴퓨터에 정보 공급
출력장치: 연산 결과를 사용자, 다른 컴퓨터에 보내줌

컴퓨터 5가지 구성요소: 입력, 출력, 메모리, 데이터베이스, 제어 유닛 (데이터베이스, 제어 유닛 2개를 합쳐 프로세서라고 부름)

<입출력장치>
디스플레이: 그래픽 디스플레이. 
-LCD(Liquid crystal display): 얇음, 전력소모 적음, 대부분 개인 휴대용기기가 사용
: 능동 행렬(active matrix): 매 화소 위치마다 작은 트렌지스터를 배치, 전류 정밀 제어(더울 선명한 이미지 제공)
: 화소(pixel): 영상을 구성하는 제일 작은 원소. 한 화면은 수십, 수백만개의 화소로 이루어짐
화소는 비트맵(bit map)이라 불리는 비트 행렬로 표현됨. 1024x268 ~ 2048x1536개의 화소로 구성됨. 
	
<상자를 열고>
-프레임 버퍼(frame buffer 또는 raster refresh buffer): 스크린 화상을 여기에 저장했다가 화소들을 재생 속도에 맞춰 그래픽 디스플레이로 보냄. 
-터치스크린: 정전용량 감지 기법(전기통하게)
-집적 회로(integrated circuit, IC) 또는 칩(chip): 수천만의 트랜지스터가 결합된 부분. 
- 프로세서(CPU): 예로, ARM 프로세서(큰 것, 작은 것). 프로그램 지시대로 일을 하는 부분. 
		    데이터패스와 제어 유닛 두 부분으로 구성됨.
-데이터패스(datapath): 산술 연산 수행
-제어 유닛(control unit): 명령어에 따라 데이터패스, 메모리, 입출력 장치가 할 일을 지시함. 
-메모리: 실행중인 프로그램, 그가 필요로 하는 데이터를 기억함. 메모리는 DRAM, 캐시 메모리(cache memory) 두 부분으로 이루어짐.
-DRAM: 집적회로로 만든 메모리 일종. 어떤 위치든지 임의 접근 가능.
-캐시 메모리(cache memory): DRAM 버퍼 역할을 하는 작고 빠른 메모리임. SRAM 기술을 이용함.
-SRAM(static random access memory): DRAM보단 빠르고, 보다 집적도가 낮아 가격이 비쌈. DRAM, SRAM 둘은 메모리 계층 구조의 두 계층을 구성함.

-명령어 집합 구조(instruction set architecture) 또는 단순히 구조(architecture): 프로그래머가 알아야하는 명령어들이 있음. 하위 계층 소프트웨어 간의 인터페이스로, 인터페이스 추상화에 가장 중요한 것이라고 할 수 있음. 
-ABI(application binary interface): 프로그래머에게 기본 제공되는 기본 명령어 집합과 운영체제 인터페이스를 합쳐 ABI라 부름.  컴퓨터간 이진 이식성 표준 정의.


<데이터의 안전한 저장소>
휘발성 메모리(volatile memory): 컴퓨터 내부의 메모리는 대부분 휘발성 메모리임. 전원이 꺼지면 메모리가 사라짐.
비휘발성 메모리(nonvolatile memory): 전원이 꺼져도 사라지지 않는 데이터.
메인 메모리(main memory 또는 primary memory): 1차 메모리. 실행되는 동안 데이터와 프로그램을 기억하는 휘발성 메모리
보조기억 장치(secondary memory): 메모리 계층 구조에서 메인 메모리보다 한 단계 아래 계층에 해당됨. 자디 디스크(magnetic disk)-(서버컴)가 주종이 됨. 
플래시 메모리(flash memory): 비휘발성 반도체 메모리. 개인 휴대용 기기(PMD)는 크기와 모양의 제약때문에 자기 디스크 대신 비휘발성 반도체 메모리인 플래시 메모리를 사용함. DRAM보다 훨씬 싸고 비휘발성이고 느림. 전력소모 적어 소용량 생산 가능. 

<컴퓨터 간 통신>
-통신, 자원 공유, 원격 접근(멀리 떨어진 컴퓨터 쉽게 이용)
이더넷(Ethernet): 네트워크 중 널리 알려짐. 이더넷으로 연결할 수 있는 거리는 약 1km. 근거리 네트워크(LAN, Kocal area Network)의 일종.
웹(World Wide Web): 여러 대륜을 연결하여 웹을 지원하는 인터넷의 근간을 이루는 네트워크는 wide area network, WAN-광섬유로 연결



1.5 프로세서, 메모리 생산 기술
-트랜지스터(transistor): 전기로 제어되는 온오프 스위치
-집적회로: 수십 수백개 트랜지스터를 칩 하나에 집적 시킨 것-초대규모집적회로(very large scale intergrated circuit, VLSI)

<집적회로 만들기>
-실리콘: 반도체(전기가 통하긴 하는데 썩 잘 통하진 않음). 양도체, 절연체, 스위치 세가지 중 하나로 바꿀 수 있음.
-양도체: 초소형 구리, 알루미늄 전선 등
-절연체: 플라스틱 피복, 유리 등… 전기가 안통하는 물질
-스위치: 조건에 따라 도체도 절연체도 됨 <- 트랜지스터!

실리콘 결정 괴(silicon crystal ingot): 큰 소시지같이 생긴 괴를 만들며 시작.
웨이퍼(wafer): 실리콘 결정 괴를 0.1 인치 이하 얇게 잘라 만듦. 
*결함(defect): 웨이퍼 자체에 생긴 흠집 등 => 완벽한 웨이퍼를 만들지 못하는 이유
다이(die) 또는 칩 만들기: 웨이퍼에 독립 컴포넌트 여러개를 만들기 위해 컴포넌트별로 자르는 것
*수율(yield): 정상 다이 / 전체 다이
본딩(bonding): 결함이 없는 다이를 패키지의 입출력 핀과 연결. 



-정답: 3번, 마스크 비용은 고정비라서 수천·수만 개를 찍을수록 1개당 분담되는 비용이 줄어든다.



1.6 성능 
: 소프트웨어, 하드웨어 성능 측정이 아주 어려움.

성능의 정의: 두 컴퓨터에서 같은 프로그램을 실행했을 때 먼저 끝나는 쪽이 이김
-응답시간(response time): 작업 개시에서 종료까지의 시간(실행시간(execution time))
-처리량(throughput): 일정시간 동안 처리하는 작업의 양 (대역폭(bandwidth))



<성능 측정>
: 벽시계 시간(wall-clock time), 응답시간, 경과시간(elapsed time) - 한 작업을 끝내는 데 필요한 전체 시간: 경과 시간
CPU 실행시간 또는 CPU 시간: 경과시간과 비교해서 프로세서가 순수하게 이 프로그램을 실행하기 위해 소비한 시간
사용자 CPU 시간(user CPU time): 프로그램 자체에 소비된 CPU 시간
시스템 CPU 시간 : 운영체제가 프로그램 수행을 위해서 소비한 CPU 시간 근데 이 둘을 나누는 것도 어려움

<프로그램 성능의 이해>
클릭 사이클, 틱, 클럭 틱, 클럭 주기, 클럭, 사이클: 일정한 속도를 가지고 동작하는 프로세서 클럭 한 주기 동안의 시간. 하드웨어 이벤트가 발생하는 시점을 결정하는 클럭- 클럭 속도는 클럭 주기의 역수

<CPU 성능, 성능 인자>

: 클럭 사이클 길이 줄이거나 프로그램 실행에 필요한 클럭 사이클 수를 줄이면 성능을 개선할 수 있음. 



<명령어 성능>

명령어당 클럭 사이클 수(clock cycles per instruction, CPI): 프로그램 전체 일부에서 명령어 하나에 필요한 평균 클럭 시수


<고전적인 CPU 성능식>






<성능식의 세가지 인자값 구하기>

-성능을 결정하는 기본 구성 요소 및 각 요소의 측정치


CPI는 명령어 배합(instruction mix)에 따라 달라짐. -> 클럭 속도가 같더라도 명령어 개수와 CPI는 반드시 비교해야 한다. 

클럭 사이클당 명령어 수 (IPC, CPI의 역수)/터보 모드




1.7 전력 장벽
: 지난 36년간 클럭 속도와 소비 전력이 같이 증가함. 
CMOS(complementary metal oxide semiconductor): 집적회로 주된 기술. 


최근 성장이 정체된 이유: 상용 마이크로프로세서의 냉각 문제때문에 실제로 사용할 수 있는 전력이 한계에 도달했음 

에너지 소비 주 원인: 동적 에너지(dynamic energy)-트랜지스터가 0에서 1 혹은 1에서 0으로 스위칭하는 동안에 소비되는 에너지 

스위칭 빈도: 클럽 속도의 함수. 트렌지스터의 용량성 부하는 출력 단자에 연결된 트랜지스터의 개수(팬아웃)와 공정 기술의 함수임.
공정기술은 도선과 트랜지스터 용량을 결정함. 
공정 기술이 강해질 수록 전압이 낮아지고, 전력은 전압에 비례하므로 소비전력이 낮아질 수 있었음. 그래서 시간이 지날수록 전력의 증가세가 낮아짐.
문제: 전압을 더 낮추면 트랜지스터가 누설하는 전류가 너무 커짐. 




1.8 현저한 변화: 단일 프로세서 -> 멀티프로세서
: 단일 프로세서에서 프로그램 응답시간을 줄이는 것 대신 여러 프로세서가 있는 마이크로프로세서를 생산하는 것이 (응답시간보다) 처리량 개선에 더 효과가 있음.
프로세서: 코어 / 마이크로프로세서: 멀티코어 마이크로프로세서라고 부름(혼선 방지)

<하드웨어/소프트웨어 인터페이스>
병렬성, 파이프라이닝
프로그래머가 명시적 병렬 프로그램을 작성하는 것이 어려운 이유
성능을 중시하는 프로그래밍-병렬 프로그래밍은 프로그래밍의 어려움을 가중시킴: 프로그램이 정확하기만 하면 되는게 아니고 빠르기까지 해야함(안그럼 병렬로 하는 이유가 없음)
응용 분할, 분할된 일 스케줄링 및 조정의 오버헤드가 작아야만 병렬 하드웨어가 빠르게 수행됨. -> 통신 및 동기화 오버헤드를 줄이기 위한 각별한 주의가 필요. 
*GPU는 병렬성에 의존함함



1.9 실제 예시: Intel Core i7 벤치마킹
: Intel Core i7을 예로 들어 성능, 전력 측정 방법을 설명함

<SPEC CPU 벤치마크>
작업부하(workload): 사용자가 실제로 실행하는 응용 프로그램 모음, 또는 그런 모음과 유사한 특성을 갖도록 실제 프로그램에서 발췌하여 구성한 프로그램 집합. 
-> 두 컴퓨터 시스템 평가시 두 컴퓨터에서 같은 작업부하의 실행시간만 비교하면 됨. 근데 대부분은 쉽지않아 벤치마크를 사용함.
벤치마크: 컴퓨터 성능 비교를 위해 선택된 프로그램. 사용자의 실제 작업부하에 대한 성능을 잘 반영할 것으로 생각되는 프로그램들로 구성된 작업 부하. 

SPEC(System Performance Evaluation Cooperative): 최신 컴퓨터 시스템을 위한 표준 벤치마크를 만들기 위해 여러 컴퓨터 회사가 자금을 대고 지원하여 만들어짐. 정수형 벤치마크, 부동 소수점 벤치마크 등.

SPECratio: 실행시간을 정규화한 결과. 이게 클수록 성능이 더 좋음. (실행시간의 역수)

<SPEC 전력 벤치마크 SPECpower>
: 에너지, 전력 측정을 위한 벤치마크가 추후 추가됨. 일정시간동안 작업부하를 10%씩 증가시키면서 서버 전력 소모를 측정함. 프로세서, 캐시, 메인메모리 사용, 자바 가상 머신, 컴파일러, 가비지 컬렉터, 운영체제 일부를 작동시킴. 


1.10 Python으로 작성한 행렬 곱셈 프로그램



오래걸린다. 2장에서 성능 개선 방법 알려줌 (c언어가 파이썬보다 더 나음)

데이터 수준 병렬성, 명령어 수준 병렬성, 메모리 계층 최적화, 스레드 수준 병렬성(c언어>파이썬)




1.11 오류 및 함정
: 많은 사람들이 공통적으로 잘못 아는 부분(오류) 설명, 쉽게 저지를 수 있는 실수(함정) 설명.

함정 예시: 컴퓨터 한 부분만 개선하고 전체 성능이 좋아지리라고 기대하는 것

Amdahl의 법칙: 개선 후의 프로그램 실행시간간

오류: 이용률이 낮은 컴퓨터는 전력 소모가 작다.
서버의 작업부하는 가변적이므로 이용률이 낮을 때의 전력 효율이 중요함. 서버 부하가 작을 떄도 최대 전력의 상당 부분을 사용하고 있음.

오류: 성능에 초점을 둔 설계, 에너지 효율에 초점을 둔 설계는 서로 무관하다
에너지 = 전력을 시간에 대하여 적분한 것.
어떤 하드웨어, 소프트웨어 최적화 기술이 에너지를 더 소비하더라도 실행시간을 줄여 전체 에너지를 절약하기도 함.


함정: 성능식 일부를 성능 척도로 사용하는 것
성능의 세 인자 중 두 개만을 사용해서 성능을 비교하면 오류 가능성이 커짐.
MIPS(Million Instruction per second): 실행시간 대신 사용가능한 척도 중 하나. 프로그램의 실행 속도를 백만개 명령어 단위로 나타냄. 빠른 컴퓨터일수록 높은 값을 가짐. 






a) MIPS
 MIPS = (클럭 속도 / CPI) ÷ 10^6
A: 4 GHz / 1.0 = 4000 MIPS
B: 4 GHz / 1.1 ≈ 3636 MIPS
 → A가 MIPS가 더 높다.
b) 실행시간
 T = (명령어 개수 × CPI) / 클럭 속도
A: (100억 × 1.0) / 4 GHz = 10/410/410/4 = 2.5 s
B: (80억 × 1.1) / 4 GHz = 8.8/48.8/48.8/4 = 2.2 s
 → B가 실제로 더 빠르다
요점: MIPS는 높아도 실제 성능(실행시간)이 더 좋다는 보장은 없다.



1.12 결론
명령어 집합 구조: 하드웨어와 하위 소프트웨어간의 인터페이스. 이것을 고정시키면 동일한 소프트웨어를 실행시키면서도 가격과 성능이 서로 다른 여러가지 구현이 가능함. 

실행시간만이 흠잡을데 없이 유효한 성능 척도임.

마이크로프로세서 설계에서 가장 중요한 자원: 다이면적 -> 에너지 효율(바뀜)

병렬성: 성능. 멀티코어를 잘 병렬시켜 성능을 높이기 
