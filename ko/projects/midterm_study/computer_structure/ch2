CH2
2.명령어: 컴퓨터 언어



2.1 서론 
명령어(instruction): 컴퓨터 언어에서 단어 / 명령어 집합(instruction set): 컴퓨터 언어에서 어휘
ARMv7 : MIPS와 유사함. 2017~2020년 사이에 1000억개가 넘는 ARM프로세서가 제조되어 세계에서 가장 많이 쓰이는 명령어 집합이 됨.
Intel x86: PC, 포스트 PC 시대 클라우드 컴퓨터 모두를 견인하고 있음
ARMv8: 32비트 ARMv7의 주소 크기가 64비트로 확장된 프로세서임.

내장 프로그램 개념(stored-program concept): 여러 종류의 데이터, 명령어를 메모리에 숫자로 저장할 수 있다는 개념.



2.2 하드웨어 연산


설계원칙 1: 간단하게 하기 위해서는 규칙적인 것이 좋다


java 바이트 코드: 자바 인터프리터 명령어 집합
JIT(Just In Time): C 프로그램보다 컴파일이 훨씬 늦게 일어나서


2.3 피연산자
워드(word): 산술 명령어의 피연산자에는 제약이 있는데, 예시로 레지스터는 특수 위치 몇 곳에 있는 것만 사용할 수 있음.  이러한 레지스터의 크기를 워드라고 함.
그런데 레지스터는 32개로 제한함.

설계원칙 2: 작은 것이 더 빠르다.

레지스터 표현법: $00 예시로, $t0, $t1


<메모리 피연산자>
: 배열, 구조체같은 복잡한 자료구조는 레지스터 개수보다 훨씬 많은 데이터 원소가 있을 수 있음. 

데이터 전송 명령어(data transfer instruction): 메모리와 레지스터 사이에서 데이터를 이동하는 명령어

메모리 주소(memory address): 메모리에 기억된 데이터 원드에 접근하려면 명령어가 메모리 주소를 지정해야함. 명령어 상수 부분+두번째 레지스터값의 합
메모리: 주소가 인덱스 역할을 하는 큰 1차원 배열이며, 주소는 0부터 시작함. 
적재(load): 메모리에서 레지스터로 데이터를 복사해오는 데이터 전송 명령. 연산자 이름과 메모리에서 온 값을 저장할 레지스터 , 메모리 접근에 사용할 상수, 레지스터로 구성됨. 




<하드웨어/소프트웨어 인터페이스> 
컴파일러: 자료구조의 시작 주소를 데이터 전송 명령에 넣을 수 있음. 컴퓨터는 바이트 단위로 대부분 주소를 저장하지만 워드는 4바이트 주소(워드를 구성하는) 중 하나를 사용함. -> 연속된 워드 주소는 4씩 차이가 남. (세번째 워드 바이트 주소:8)

정렬 제약(alignment restriction): MIPS에서 워드 시작 주소는 항상 4의 배수여야함. 메모리 내에서 데이터는 자연스러운 경계를 지켜서 정렬되어야 한다는 요구조건. 
컴퓨터: 제일 왼쪽(최상위 big end) 바이트 주소를 워드 주소로 사용하는 쪽/제일 오른쪽 (최하위 little end) 바이트 주소를 워드 주소로 사용하는 쪽 두 종류로 나누어짐. MIPS는 최상위 big endian 계열 
	
저장(store): 적재와 반대로 레지스터에서 메모리로 데이터를 보내는 명령 (저장 명령의 생김새는 적재와 같음) 연산자 이름, 저장할 데이터를 가진 레지스터, 배열 원소 선택에 사용할 변위, 베이스 레지스터-store word

DRAM 메모리 주소: 10진수가 아닌 이진수 단위로 표시됨 



<하드웨어/소프트웨어 인터페이스>
레지스터 스필링(spilling register): 자주 사용하지 않는 변수를 메모리에 넣는 일
레지스터가 메모리보다 속도가 빠르고, 사용하기도 더 편리함. 처리량도 많음. 따라서 컴파일러가 레지스터를 잘 써야함.


<상수 또는 수치 연산자>
프로그램 연산에서 상수를 사용하는 경우: 배열의 다음 원소를 가리키도록 인덱스를 증가시키는 경우. 

-레지스터 $s3에 상수 4를 더하는 코드


$s1+AddrConstant4: 상수 4가 저장되어있는 메모리 주소
수치 피연산자(immediate 피연산자): 적재명령을 사용하지 않는 방법. 상수인 산술 연산자를 제공하는 것, 그 상수. addi

-레지스터 $s3에 4를 더하기

	상수 필드를 갖는 산술 명령어를 사용하면, 매번 메모리에서 상수를 가져오는 것보다 연산이 훨씬 빨라지고 에너지를 덜 소모하게 됨

	상수 0의 역할: 명령어에 여러 변형을 제공, 명령어 집합을 단순하게 함. 예로 복사(move) 연산: 피연산자 중 하나가 0인 add 명령어임.

칩 내의 레지스터 개수가 증가하는 속도: 

정답: 2 매우 느리다. 하드웨어 성능(트랜지스터 수, 클럭 등)은 무어의 법칙에 따라 빠르게 발전하지만, 소프트웨어(명령어 집합 활용도, 레지스터 활용 등)는 구조적 제약으로 인해 느리게 발전한다

인덱스 레지스터: 데이터 전송 명령에서 사용되는 레지스터는 배열 인덱스값을 변위에 저장하여 배열 시작 주소를 계산하는 데 사용되도록 설계됨. 이때의 베이스 레지스터를 인덱스 레지스터라고 부름. (근데 요즘은 배열의 시작 주소가 변위 부분에 다 들어가지 않는 경우가 많아 레지스터에 넣는 것이 보통임) 



2.4 부호 있는 수와 부호 없는 수 
어떤 기수 숫자에서 i번째 자릿수 d의 값: 
(i는 0에서 시작해 왼쪽으로 갈 수록 증가함) -> 워드 내 비트에 번호 붙이기(그 비트에 해당하는 기수의 멱수를 번호로 사용) 10진수는 아래 첨자 ten, 2진수는 아래 첨자 two


MIPS 워드 내의 비트에 번호를 붙이는 방식-윗 값1011(two)의 표현

LSB(least significant bit): 가장 오른쪽 비트 (0)
MSB(most significant bit): 가장 왼쪽 비트(31)을 나타냄

MIPS워드의 길이는 32비트 -> 2의 32승가지의 서로다른 32비트 패턴을 표현할 수 있음. 

양수(부호없는수): 


오버플로우: 연산 결과가 하드웨어 오른쪽 비트들만으로는 표현이 불가능할 때

부호와 크기(sigh and madnitude): 양수와 음수를 구별하기 위해 별도의 부호를 덧붙이는 방법
부호와 크기의 단점: 1) 어디에 부호비트를 붙여야 하는지 불명확(최종 부호가 뭐가될지 모름) 2) 부호와 크기 표현법의 덧셈기는 부호를 결정하기 위해 한 단계가 더 필요함. (최종 부호가 뭐가 될지 몰라서) 3) 부호비트가 따로 붙으므로 양의 0과 음의 0을 가지게 됨 … 이런 단점때문에 해당 방식은 잘 안씀. 

작은 수에서 큰 수를 뺄 때 부호없는 수의 경우에 결과가 어떻게 될까? -> 0으로 시작되는 수에서 빌리게 되므로 1로 시작하는 수가 됨. 
-> 0이 앞에 나오면 양수, 1이 앞에 나오면 음수가 되며 부호있는 이진수를 표현하는 방식을 2의 보수법(two’s complement)이라고 함

0부터 2의 31승-1까지는 부호없는 정수와 같은 표현법 그 후 가장 큰 음수 ~ 크기가 하나씩 줄어듦 // 오늘날의 컴퓨터는 모두 2의 보수로 표현하게됨. 

부호 비트(MSB): 모든 음수는 MSB가 1이므로 하드웨어가 양수인지 음수인지는 이거만 보면 댐




부호 확장(sign extention): 부호있는 적재의 경우 레지스터의 남는 곳을 채우기 위해 부호를 반복하여 복사하게됨. -> 레지스터 길이에 맞춰 그 값을 정확하게 표현 가능. 
(부호없는 적재: 데이터 왼쪽 빈 부분을 그냥 0으로 채움)

<바이트 적재 명령어 2개>
lb(load byte): 바이트를 부호있는 수로 간주. 남은 24비트를 부호확장해서 채움
lbu(load byte unsigned): 8비트를 부호없는 정수로 간주하여 왼쪽 24비트를 0으로 채움. 보통 이걸로 사용
	정수 integer: 양수 혹은 음수 둘다 가능
	부호없는 정수 unsigned integer: 양수만 가능


	<2의 보수 연산에서 사용가능한 두가지 계산법>
2의 보수 이진수를 역부호화하는 빠른 방법 (모든 0은 1로, 모든 1은 0으로 바꾸고 거기에 1을 더함) 



n비트로 표현된 이진수를 n비트보다 큰 수로 바꾸는 방법: 부호 확장(sign extention): 16비트 수를 같은 값의 32비트 수로 바꿀 때 -> 16비트 이진수의 최상위 비트(부호 비트)로 비어있는 왼쪽 부분 채우기, 원래 16비트값은 32비트 수의 오른쪽 부분에 그대로 복사함.

(수를 나타내는 이진 비트 패턴은 하드웨어 폭에 맞추기 위해 왼쪽 비트를 숨김. 부호확장은 이들 중 일부를 복원하는 것임)



답:2의 보수 64비트 → -8
부호 없는 64비트 → 18,446,744,073,709,551,608


	1의 보수법: 절대값이 가장 큰 음수를 10…00(ten)으로 나타내고 가장 큰 양수를 01…11(two)로 나타내며 같은 개수의 양수와 음수를 나탄는 표현방법
	바이어스된 표현법(biased notation): 숫자에 일정한 값(bias)을 더하여 항상 양수로 표현되므로 이렇게 부름



	2.5 명령어의 컴퓨터 내부 표현 
레지스터 $s0~$s7: 레지스터 번호 16~23
$t0~t7: 8~15



	명령어 형식(instruction format): 위 예제에서 보인 레이아웃. MIPS 명령어의 길이는 데이터 워드와 마찬가지로 32비트임. 

	기계 코드(machine code): 기계어들의 시퀀스
	16진수(hexademical): 거의 모든 컴퓨터들의 데이터 길이는 4의 배수이므로 16진수가 많이 사용됨. 이진수 4비트는 16진수 숫자 하나로 쉽게 바꿀 수 있음. 

	


< MIPS 명령어의 필드> R 타입

op: 연산자(opcode)
rs: 첫번째 근원지(source) 피연산자 레지스터
rt: 두번째 근원지 피연산자 레지스터
rd: 목적지(destination) 레지스터. 연산결과가 기억됨
shamt: 자리이동(shift)량
funct: 기능. 기능 코드(function code)라고 부르기도 함. 

근데 이거보다 필드 길이가 더 길어야 하는 경우 : 예로 lw명령어…(레지 필드 2, 상수 필드 1) 부족함
모든 명령어 길이를 같게 하고싶다 vs 명령어 형식을 통일하고싶다

설계원칙 3: 좋은 설계는 적당한 절충이 필요하다. 
절충안 (MIPS) -> 모든 명령어 길이를 같게 하되, 명령어 종류에 따라 형식을 다르게 하는 것. 


I 타입 : 수치연산, 데이터 전송 명령어에서 사용되며 모양은 다음과 같음. 

16비트 주소를 사용하므로 lw명령은 베이스 레지스터 rs에 저장된 주소를 기준으로 
지정가능

addi 명령의 경우 레지스터를 32개 이상 사용할 수 없음(32보다 많으면 rs, rt피드가 더 커져서 모든 정보 못담음)


적재 명령-rs에 19, rt에 8, 주소 필드에 32. 
op: 하드웨어는 이걸 보고 타입을 결정
R타입: 명령어 오른쪽 절반을 필드 3개로 봄
I타입: 명령어 오른쪽 절반을 필드 하나로 봄



예제


레지스터 개수를 늘리면 명령어 형식에서 각각의 레지스터 필드는 적어도 1비트가 더 필요하므로 대부분 16 혹은 32개 레지스터를 갖게됨

MIPS 어셈블리 언어 요약

<내장 프로그램의 개념>
명령어는 숫자로 표현됨
프로그램은 메모리에 기억되어있어서 데이터처럼 읽고 쓸 수 있음 

예제

MIPS 명령어: 4) sub $t2, $t0, $t1
이유: R형식에서 op=0, funct=34 ⇒ sub, 그리고 rd=$10($t2), rs=$8($t0), rt=$9($t1).
40₁₀의 16진수: 0x28 (28₁₆)




2.6 논리 연산 명령어
packing: 비트들을 워드로 묶음
unpacking: 워드를 비트 단위로 나눔 
=> 논리 연산 명령어가 함. 

자리 이동(shift): 워드 내의 모든 비트를 왼쪽(sll)/오른쪽(srl)으로 이동시키고 이동 후 빈자리를 0으로 채움


이진수 9는 0000 1001인데, 이를 왼쪽으로 네 번 자리이동할시 1001 0000 으로 144가 된다.(2의 4승을 곱한것과같음)
srl은 2의 n승을 나눈 것과 같음 

R형식 명령어의 shamt 필드: 자리이동량 shift amount을 나타냄

AND 연산 MIPS 명령어 실행법

AND와 함께 쓰이는 이런 비트 패턴은 일부 비트를 감추는 역할을 하므로 마스크mask라고 부름

OR연산 MIPS 명령어 실행법


NOR 연산 MIPS 명령어 실행법(1이면 0으로, 0이면 1로)



NOR(Not or): 피연산자 형식 유지를 위해 NOT대신 NOR을 추가함 

XOR(exculsive or): 두 비트가 서로 다르면 1, 같으면 0
andi(AND immediate), ori(OR immediate): 16비트 상수를 32비트로 바꿀 떄 상위 16비트에 0을 삽입

<다음 중 어떤 연산이 워드 내 필드를 분리할 수 있는가?>
AND
왼쪽 자리이동 후 오른쪽 자리이동
AND 연산 :
 원하는 비트 패턴(마스크)을 준비한 뒤 AND를 수행하면 필요한 필드만 남기고 나머지는 0으로 제거됨. → 필드 분리에 가장 많이 쓰임.


왼쪽 시프트 후 오른쪽 시프트 :
 필요 없는 상위/하위 비트를 밀어내서 잘라낼 수 있음. 즉, 위치 조정 및 분리에 보조적으로 활용 가능.
둘다 쓰일 수 있지만 정석은 AND



2.7 판단을 위한 명령어
if문, goto문
<조건부 분기 conditional branch)>
beq register1, register2, L1: register1, register2가 같으면 L1로 가라
bne register1, register2, L1: register1, register2가 같지 않으면 L1로 가라 


어셈블러: 분기 주소 계산


<순환문>


기본 블록(basic block): 분기 명령을 포함하지 않으며(맨 끝에는 있을 수 있음) 분기 목적지나 분기 레이블도 없는(맨앞에는 있을 수 있음) 명령어 시퀀스.

slt: 대소 비교 명령어 (set on less than) A<B이면 1 아니면 0
slti $t0, $s2, 10 # $t0 = 1 if $s2<10


<하드웨어/소프트웨어 인터페이스>
레지스터 $zero는 0번 레지스터를 가리킴
slt, slti: 부호 있는 정수 비교 
sltu, sltiu: 부호 없는 정수 비교


2의 보수로 표현된 음수를 부호없는 정수로 보면 매우 큰 수처럼 보임
 -> 부호없는 비교 x<y를 하면 대소비교, x음수 판별 가능



<Case/Switch 문장>
: 특정 변수의 값에 따라 여러가지 중 하나를 선택하는 문장

점프 주소 테이블 또는 점프 테이블: 여러 명령어 시퀀스의 주소(프로그램상의 레이블)를 가지고있는 표. 프로그램은 점프 테이블에서 적당한 주소를 레지스터에 적재 후 이 주소를 사용해 점프함.
이것의 인덱스만 계산해서 해당 루틴으로 점프 가능. 
jr: 점프 레지스터라는 뜻의 명령어(레지스터에 저장된 주소로 점프)

*지연 분기(delayed branch): MIPS 어셈블러가 어셈블리 언어 프로그래머에게 이 지연분기가 보이지 않도록 해줌. 






C에는 if, switch, for, while, do-while 등 다양한 판단문과 반복문이 있음.
MIPS 같은 하드웨어 수준 ISA에서는 단순한 분기(branch) 명령만 존재.
📌 따라서 가장 잘 설명하는 것은
 ④ "판단문의 종류가 많으면 코드의 줄 수가 줄어들고, 실행할 연산의 개수도 줄어든다."
 → 고급언어(C)는 사람이 보기 좋게 다양한 제어문 제공,
 → 저급언어(MIPS)는 하드웨어 단순화를 위해 최소한의 분기만 지원.
& / | → 비트 단위 연산 (하드웨어적으로 단일 AND/OR 게이트로 처리 가능)&& / || → 조건부 연산 (short-circuit evaluation) → 이는 고급언어에서만 의미가 있음.MIPS는 단순히 하드웨어적 논리 연산만 지원하므로 &와 |만 있으면 충분함.
📌 따라서 정답은
 ① "&와 |는 논리 연산 AND/OR로 구현하고, &&와 ||는 조건부 분기로 구현하기 때문이다."



2.8 하드웨어의 프로시저 지원
프로시저(procedure): 제공되는 인수에 따라 특정 작업을 수행하는 서브루틴. 소프트웨어가 추상화를 구현하는 방법 중 하나임.
인수: 프로시저에 값을 보내고 결과를 받아옴. 프로그램의 다른 부분 및 데이터와 프로시저 사이의 인터페이스 역할. 

<프로그램이 프로시저를 실행할 때의 6단계>
프로시저가 접근할 수 있는 곳에 인수를 넣는다
프로시저로 제어를 넘긴다
프로시저가 필요로 하는 메모리 자원을 획득한다
필요한 작업을 수행한다
호출한 프로그램이 접근할 수 있는 장소에 결과값을 넣는다
프로시저는 프로그램 내의 여러 곳에서 호출될 수 있으므로 원래 위치로 제어를 돌려준다
<프로시저 호출 관례에 따른 레지스터 할당>
$a0-$a3 전달할 인수를 가지고있는 인수 레지스터 4개
$v0-$v1 반환값을 갖게 되는 값 레지스터 2개 
$ra 호출한 곳으로 되돌아가기 위한 복귀 주소를 가진 레지스터 1개 

jal(jump-and-link) : 지정 주소로 점프하면서 동시에 다음 명령어의 주소를 레지스터(MIPS에서는 $ra)에 저장하는 명령어
jal ProcedureAddress
프로시저와 호출한 곳 사이에 주소 또는 링크를 형성함 
복귀 주소(return address): 돌아갈 수 있게 레지스터 $ra에 기억되는 링크

jr $ra : ra주소로 점프
호출 프로그램(caller): $a-$a3에 전달할 인수값을 넣고 jal X 명령을 이용해 프로시저 X(피호출 프로그램(callee)로 점프함. 
피호출 프로그램: 계산 끝낸 후 계산 결과를 $v0-$v1에 넣은 후 jr $ra 명령 실행해 복귀함 

명령어 주소 레지스터(instruction address register)혹은 프로그램 카운터(PC, program counter): 현재 실행중인 명령어의 주소를 가진 레지스터 
jal : 복귀시 바로 다음 명령어부터 실행하도록 PC+4를 레지스터 $ra에 저장함 


<더 많은 레지스터 사용>
모든 레지스터는 복귀하기 전 프로시저 호출 전 상태로 돌려놔야함.-> 레지스터 스필링이 필요
스택(stack): 레지스터 스필링에 이상적인 자료구조(후입선출) 
스택 포인터: 레지스터 값 하나가 스택에 저장되거나, 스택에서 복구될 때마다 한 워드씩 조정됨 , 29번 레지스터 할당되어있음, $sp
넣는건 푸시(포인터값 감소), 꺼내는 건 팝(포인터 값 증가) -> 높은 주소에서 낮은 주소로 성장하므로


-임시 레지스터를 사용한 예제 (임시 레지스터도 저장했다가 원상복구해야한다고 가정)

<사용하지 않는 레지스터 값을 쓸데없이 저장했다 복구하는 일 방지하는 법>
$t0-$t9: 프로시저 호출시 피호출 프로그램이 값을 보존해주지 않는 임시 레지스터
$s0-$s7: 프로시저 호출 전과 값이 같게 유지되어야 하는 변수 레지스터(피호출 프로그램이 이 레지스터를 사용하면 원래 값을 저장했다가 원상복구함)
-> 레지스터 스필링 줄이기 

<중첩된 프로시저>
말단(leaf) 프로시저: 다른 프로시저를 호출하지 않는 프로시저
재귀 프로시저, 프로시저를 호출하는 프로시저가 존재 (호출시 조심)


<가정> 주 프로그램이 인수값 3으로 프로시저 A를 호출함
->레지스터 $a0에 3을 넣고 jal A 명령을 실행하게 됨
프로시저 A가 다시 인수 7(역시 $a0에 들어감)을 jal B로 프로시저 B를 호출함.
-> A가 다 안끝나서, 레지스터 $a0사용에서 충돌 발샘. $ra 복귀 주소에서도 충돌. 

=> 방법: 값이 보존되어야하는 모든 레지스터를 스택에 넣는다.
인수 레지스터(a), 임시 레지스터(t) 중 프로시저 호출 후에도 계속 사용해야 하는 것을 모두 스택에 넣음. 
피호출 프로그램은 복귀 주소 레지스터 $ra, 저장레지스터(s) 중 피호출 프로그램이 사용하는 레지스터를 모두 저장함.   스택 포인터는 저장되는 레지스터 개수에 맞추어 조정됨. 복귀 후 레지스터 원상복구 & 스택 포인터 조정



프로시저 호출 전후의 값 보존 관계: 스택을 보존해서 스택에 저장한 값과 같은 값을 꺼낼 수 있게 보장하고있음. 
$sp보다 위쪽에는 값을 못쓰게 함 -> $sp 윗부분 스택을 원상태로 유지함. $sp 자체는 뺀 값만큼 피호출 프로그램이 도로 더해서 원값을 유지. 다른 레지스터는 스택에 저장했다가 다시 꺼내서 원값 유지.

기억된 내용을 해석하는 것은 데이터형(type), 저장 유형(storage class)에 따라 달라짐
C는 자동(프로시저 종료시 없어짐), 정적(프로시저에서 빠져나와도 존재) 두가지 저장 유형을 가짐. 
나머지는 자동 변수. 
MIPS의 정적변수 접근: 전역포인터 global pointer, $gp  



<새 데이터를 위한 스택 공간의 할당>
프로시저 프레임 procedure frame 또는 액티베이션 레코드 activation record: 프로시저의 저장된 레지스터, 지역변수를 가진 스택 영역
프레임 포인터 frame pointer: 프로시저 프레임(저장된 레지스터와 지역변수 위치)을 표시하는 값

-프로시저 호출 후 보존되는 것(프레임 포인터 레지스터, 전역 포인터 레지스터), 보존되지 않는 것


별도의 프레임 포인터 사용 여부와 상관없이 액티베이션 레코드는 항상 스택에 존재함. 
스택 포인터 값이 프로시저 내에서 바뀔 수도 있으므로 메모리 내 지역변수 변위는 변수가 프로시저 어느 부분에서 사용되느냐에 따라 달라짐


<새 데이터를 위한 힙 공간 할당>
-정적 변수, 동적 자료구조를 위한 메모리 공간의 필요성
스택: 최상위 주소에서부터 아래쪽으로 자람. 최하위 부분은 사용 유보

텍스트 세그먼트: UNIX 목적 파일에서 소스 파일 루틴의 (스택 다음) 기계어가 들어가는 부분.
정적 데이터 세그먼트: 상수, 기타 정적 변수들

힙: 그 다음 부분에 들어가는 공간. 스택과 힙은 서로 마주보면서 자람.
malloc() : 힙에 공간 할당 후 이 공간을 가리키는 포인터를 결과값으로 보냄.
free(): 포인터가 가리키는 힙 공간을 반납함. 
메모리 누출(memory leak): 사용이 끝난 공간을 반납하는 것을 잊어버리면 메모리 누출이 발생. 메모리 부족으로 운영체제가 붕괴될 수 있음.
매달린 포인터(dangling pointer): 공간을 너무 일찍 반납했을 때 프로그램 의도와 상관없이 엉뚱한 것을 가리키게됨. 
-> 자동 메모리 할당과 가비지 컬렉션을 사용하는 이유     (자바가)
 
=> 자주 생기는 일을 더 빠르게 라는 원칙의 또다른 예가 됨. 

인수가 4개보다 더 많을때: 나머지 인수를 프레임 포인터 바로 위 스택에 넣기 (프레임 포인터를 사용하여 스택 변수에 접근하면 변위값이 항상 같으므로 매우 편리함)

누적합 프로그램
-재귀 프로시저 중 재귀 호출을 사용하지 않고 반복 기법으로 구현할 수 있는 것이 있음. 
반복기법: 프로시저 호출 관련 오버헤드를 제거해 성능향상이 가능


꼬리 호출: 프로시저 호출 sum(3,0) -> sum(2,3), sum(1,5), sum(0,6)의 재귀적 호출이 일어나서 결과 6이 네번 반환 되게 됨. 이와 같은 재귀적 호출을 꼬리 호출이라함. 

Q. C, Java 에 대한 설명중 일반적으로 사실인 것은?
자바에서는 데이터 관리가 자동적으로 되지만 C 프로그래머는 직접해야한다.
Java: 가비지 컬렉션(Garbage Collection, GC)이 있어서 사용이 끝난 객체는 자동으로 메모리에서 해제됩니다. 프로그래머가 직접 free() 같은 해제를 하지 않아도 됨.
C: 동적 메모리를 malloc(), calloc(), realloc()으로 할당하고, 사용이 끝나면 반드시 free()로 직접 해제해야 합니다. 안 하면 메모리 누수(memory leak)가 발생합니다.

C는 자바보다 포인터 버그와 메모리 누출 버그가 많이 발생한다.
C: 포인터(pointer)를 직접 다루기 때문에 잘못된 주소 접근(segmentation fault), 메모리 해제 후 재사용(use-after-free), 이중 해제(double free) 등 다양한 버그 발생 가능성이 높음.
Java: 포인터 연산이 없고, 모든 객체는 참조(reference)로 다루며, GC가 해제까지 관리하므로 포인터 버그나 메모리 누수 가능성은 훨씬 적음. (단, 자바에서도 레퍼런스를 계속 유지하면 "가비지 컬렉터가 수거하지 못하는 메모리 누수"는 여전히 발생할 수 있음.)





2.9 문자, 문자열
ASCII(American Standard Code for Information Interchange): 오늘날 대부분 컴퓨터가 아스키로 문자를 사용함. 



MIPS 바이트 전송 명령어 
lb(load byte) : 메모리에서 한 바이트를 읽어서 레지스터의 오른쪽 8비트에 채우는 명령어. 
sb(store byte): 레지스터의 오른쪽 8비트를 메모리로 보내는 명령어.
-한 바이트를 복사할때

-가변적인 문자열의 길이를 표현하는 세가지 방법
문자열 맨 앞에 길이를 표시
같이 사용되는 변수에 그 길이를 표시
마지막에 문자열의 끝을 표시하는 특수문자를 두기
-> C언어: 문자열 끝에 값이 0(끝을 뜻함)인 바이트(null) 하나를 두는 방법을 택함. 



컴파일러가 말단 프로시저를 만나면 우선 이 레지스터를 쓰고 부족하면 그때 저장해야 하는 레지스터를 사용함.


<JAVA의 문자와 문자열>
유니코드: 인간이 사용하는 거의 모든 언어의 자모를 수용할 수 있는 범용 인코딩.

유니코드엔 많은 자모(alphabet)이 있음. 문자표현에 16비트씀
하프워드(halfword): 16비트 데이터에 대한 적재, 저장 명령어 (MIPS 명령어 집합)

lh(load half): 메모리에서 16비트를 읽어와서 레지스터의 우측 16비트에 넣음. 하프워드를 부호 있는 수로 취급. 레지스터 상위 16비트를 부호확장하여 채움. 
lhu: 부호 없는 수 적재 (그래서 얘가 좀더 많이 쓰임)
sh(short half): 레지스터 우측 16비트를 메모리에 씀. 

-하프워드 복사 방법


문자열은 표준 자바 클래스. 내장된 특수 지원 기능과 연접(concatenation), 비교, 변환 등 미리 정의된 메소드를 갖고있음

MIPS 소프트웨어에서, 1바이트면 충분한 char 변수도 4바이트를 할당함 그러나 C 문자열 변수나 바이트 배열은 한 워드에 4바이트씩 묶어서 넣음.  자바 문자열 변수나 short 배열은 한 워드에 두 하프워드씩 넣음. 

웹 페이지는 국제적이라서 아스카 말고 유니코드를 보통 씀. 


I. C와 Java의 문자 및 문자열에 대한 사실 여부
C의 문자열은 Java 문자열보다 메모리를 절반만 차지한다.
 → 대체로 사실.
C: char는 1바이트(ASCII 중심). 문자열은 char[] + '\0' 종료.
Java: char는 2바이트(UTF-16). 문자열은 객체(String class)라서 부가 메모리도 필요.
 → 따라서 C 문자열이 훨씬 메모리 효율적.
C와 Java에서 문자열이라는 용어는 1차원 문자 배열에 대해 비공식적으로 사용된다.
 → C에서는 사실, Java에서는 아님.
C: 문자열 = 사실상 char[] (null 종료).
Java: 문자열 = String 클래스 객체. 단순 배열과 동일시하지 않음.
C와 Java 문자열 모두 null(0)로 문자열의 끝을 표시한다.
 → 거짓.
C: '\0' (null character)로 끝 표시.
Java: String은 내부에 길이 정보를 저장하므로 '\0' 종료 없음.
문자열에 대한 연산(예: 길이 계산)은 Java보다 C가 빠르다.
 → 대체로 거짓.
C: 길이(strlen) 계산은 null 문자 찾을 때까지 선형 탐색. O(n).
Java: String.length()는 내부에 길이가 저장돼 있어 O(1).
 → 문자열 연산 속도는 Java가 일반적으로 유리.
✅ 따라서 I번 정답: ①만 사실 (조건에 따라 ② 일부 맞지만, 시험에서는 오답으로 간주될 확률 큼).

II. 값 1,000,000,000 (10억)을 저장할 때 메모리를 가장 많이 쓰는 것은?
C의 int
일반적으로 4바이트 (32비트 시스템·표준 C에서 최소 16비트지만, 보통 32비트).
C의 string ("1000000000")
"1000000000"은 10글자 + '\0' (1바이트) = 11바이트.
즉, int(4바이트)보다 더 큼.
Java의 string ("1000000000")
Java String: 내부는 UTF-16 char[] (각 문자가 2바이트).
"1000000000" → 10글자 × 2 = 20바이트 + 객체 오버헤드(16바이트 이상).
따라서 가장 메모리를 많이 씀.
✅ 따라서 II번 정답: ③ Java의 String.

파일 접미어 .jpg, .pdf 등을 사용하는 이유: 파일 종류를 나타내지 않으면 프로그램과 데이터 간의 미스매치가 발생할 수 있다(각각 다르게 해석해서)


2.10 32비트 수치와 주소를 위한 MIPS의 주소지정 방식
32비트 상수 처리법 & 32비트 명령어 주소를 분기, 점프명령어 내 표시하는 방법

<32비트 수치 피연산자>
큰 상수가 필요할 때: lui(load upper immediate)-MIPS는 레지스터의 상위 16비트에 상수를 넣음 하위 16비트는 그 다음 다른 명령으로 채움
-lui의 동작

컴파일러, 어셈블러는 큰 숫자를 직접 못다루므로 잘게 자르고 레지스터에서 재조립함. (그래서 임시 레지스터가 필요)

주의: addi 명령어는 16비트 상수 필드의 MSB를 상위 16비트에서 복사, 32비트 상수를 만들어 연산함. 
ori 명령어 : 상위 16비트를 0으로 채우고 연산하기 때문에 어셈블리는 ori, lui 함께 사용해 상수를 만듦

<분기와 점프 명령에서의 주소지정>
: MIPS //점프 명령에서 사용하기 (점프 명령: 6비트 op코드, 26비트 주소 필드 - J타입 형식)

상수는 왼쪽에 오른쪽은 0으로 채우기
점프 op:2, 분기주소 : 10000

조건부 분기 명령에서- 분기 주소 외 2개의 피연산자가 더 있음

PC=레지스터+분기 주소 
:프로그램 크기가 2^32까지 커지는 거 허용하면서 조건부 분기도 지원함 -> 분기 주소 크기 제한 극복

PC 상대 주소지정 방식: PC와 명령어 내 상수의 합이 실제 주소가 되는 주소지정. 하드웨어 입장에서는 PC를 일찍 증가시켜 다음 명령어를 가리키게 하는 것이 편리함.(조건부 분기는 가장 가까운 명령어로 분기하는 경향이 있으므로)
MIPS주소가 다음 명령어 주소를 가리키는 이유.

MIPS 명령어는 바이트 주소대신 워드 주소를 사용함으로서 PC 상대 주소 지정 방식의 분기 거리를 4배로 늘림, PC의 상위 4비트를 바꾸지 않고 하위 28비트를 바꿈. 

MIPS 이웃 워드 주소는 4씩 차이남. 
bne: 다음 명령어 주소에 8을 더해서 목적지 주소 구함. (다음 명령어 기준으로 분기주소를 나타내서)
loop: 주소 전체

가끔 16비트로 못나타내는 먼 곳으로 분기할 떄, 큰 주소, 상수를 처리할 때와 같이 해결함. (점프 삽입 후 조건을 반대로 만들어서 점프 건너뛰기 아니긔를 결정하게 함)


<MIPS 주소지정 방식 요약>
주소지정 방식(addressing mode): 여러 형태의 주소 표현
수치(immediate) 주소지정: 피연산자는 명령어 내의 상수임.
레지스터 주소 지정: 피연산자는 레지스터임.

베이스 또는 변위(displacement) 주소지정: 메모리 내용이 피연산자. 메모리 주소는 레지스터와 명령어 내의 상수를 더해서 구함. 
PC 상대 주소지정: PC 값과 명령어 내 상수 합을 더해서 주소를 구함.
의사 직접(pseudodirect) 주소지정: 명령어 내 26비트를 PC 상위 비트들과 연접해서 점프 주소를 구함.
*마이크로프로세서는 거의 64비트로 주소 확장이 가능

<기계어 해독>
기계어로부터 원래의 어셈블리 언어를 추출하는 작업. (코어 덤프 읽을 때 필요)




3. addi
4.sll
5. mfc0
6 정의되지 않은 op코드

I. 3 (분기문 전 32K ~ 후 32K)
II. 6 (상위 4비트 동일한 256MB 블록 내 임의 주소)
III. 2 (R-format, 실제로는 sll $zero,$zero,0 = nop)



2.11 병렬성과 명령어: 동기화
태스크 동기화: 태스크가 독립적일때는 병렬 처리가 쉬움, 협력적일때는 한 태스크 일이 끝나야 쓸 수 있으므로 태스크 동기화가 필요홤.
데이터 경쟁관계 data race: 태스크들이 동기화되지 않았을 때 일어날 수 있음. (이벤트가 일어나는 순서에 따라 프로그램의 결과가 달라질 수 있는 상황) 다른 스레드에서 나온 두 메모리 접근이 같은 위치를 향하고 그 중 적어도 하나가 쓰기이고, 잇따라서 이들이 일어날 때 형성함.

lock, unlock
상호 배제: 단 하나의 프로세서만이 작업할 수 있는 영역을 생성하는 것
멀티프로세서에서 동기화를 구현할 떄: 메모리 주소 읽고 수정하는 것을 원자적으로 처리할 능력을 가진 하드웨어 프리미티브가 있어야 함. 

동기화 연산 구축하기
-원자적 교환 atomic exchange 또는 atomic swap: 레지스터 값을 메모리값과 서로 맞바꿈.
lock:0 사용 가능 1 사용 불가
-명령어 하나 말고 두개로 처리하기: 두번째 명령어가 이 한 쌍의 명령어가 원자 실행됐는지를 나타내는 값을 반환함.(원자적이라면 값을 바꿀 수 없음)
-> load linked, store conditional 이라 불리는 특수 저장 명령어가 있어 순차적으로 사용됨. 

store conditional: (1) 레지스터 값을 메모리에 저장하는 일 (2) 성공하면 레지스터 값을 1 혹은 0으로 바꾸는 일 두가지를 동시에 수행함.
load linked : 초기값을 반환
-> 원자적 교환을 구현하게 되는 명령어 시퀀스

ll, sc 사이 프로세서가 끼어들어 메모리 값을 수정하면 sc는 $tc에 0을 반환하므로 again으로 가서 코드 시퀀스를 다시 실행함. 결국 $s1의 주소에 있는 메모리 내용과 $s4 사이의 원자적 교환을 달성하게 됨. 

원자적 교환은 다중 프로세스를 다루는 데에도 유용함.

load linked/store conditional 메커니즘의 또 다른 장점: atomic compare and swap 또는 atomic fetch and increment같은 다른 동기화 프리미티브들을 만드는데 사용할 수 있음. 
(근데 두 명령어 사이에 명령어들이 너무 많이 들어가면 교착상태 deadlock 발생 가능)



2.12 프로그램 번역과 실행 
비휘발성 저장장치 파일에 저장된 C 프로그램을 컴퓨터가 실행가능한 프로그램으로 변환하기 위한 네 단계



<컴파일러>
C프로그램 -> 어셈블리 언어 프로그램 = 컴퓨터가 이해할 수 있는 명령의 기호형태. 
어셈블리 언어: 이진 기계어를 번역할 수 있는 기호화된 언어 

<어셈블러>
: 상위 수준 소프트웨어와의 인터페이스. 의사명령어(pseudoinstruction)들을 통해 하드웨어로 구현돼있지 않은 명령어들을 어셈블러가 알아서 처리하여 번역과 프로그래밍을 간편하게 해줌. 
$zero의 값을 항상 0이 되도록 함
-> move 명령어 구현에 사용 

또, blt(branch on less than) 명령어를 slt, bne 2개의 명령어로 바꿈. bgt, bge, ble 명령어가 이렇게 처리됨. 


주의: 레지스터 하나를 어셈블러 전용으로 유보해둘것

어셈블러의 주 임무: 어셈블리 프로그램을 기계어로 번역하기 / 어셈블리 언어 프로그램을 목적 파일(object file)로 바꿈. 

심벌 테이블(symbol table): 어셈블러는 분기, 데이터 전송 명령에서 사용된 모든 레이블을 여기에 저장함. 심벌, 주소 저장. 레이블 이름을 명령어가 기억된 메모리 워드 주소와 짝지어줌줌

목적 파일의 여섯 부분
-목적 파일 헤더: 파일 구성하는 부분 크기, 위치
-텍스트 세그먼트: 기계어 코드
-정적 데이터 세그먼트: 프로그램 수명동안 할당되는 데이터(정적 데이터, 동적 데이터)
-재배치(relocation) 정보: 절대 주소를 사용해야하는 명령어, 데이터 워드를 표시함
-심벌 테이블: 외부 참조같이 정의되지 않고 남아있는 레이블들을 저장함
-디버깅 정보: 각 모듈의 번역에 대한 간단한 설명 


<링커>
링커 또는 링크 에디터: 따로 어셈블된 기계어 프로그램을 결합하고 정의안된 레이블 주소를 찾아내 실행파일을 만드는 시스템 프로그램

링커의 세가지 동작
코드와 데이터 모듈을 메모리에 심벌 형태로 올려놓음
데이터, 명령어 레이블 주소 결정
외부. 내부 참조 해결
-> 레이블 주소 결정 , 구주소 신주소로 바꾸기 
모듈 메모리 주소 결정  -링커가 모듈을 메모리에 적재시 절대 참조 는 모두 실제 위치 값으로 재설정되어야 함.

실행 파일(execution file)도 생성함. 목적파일과 같은 형식. 참조는 없음(미해결 주소를 가지고있으면 그건 목적 파일임). 심벌 테이블, 디버깅 정보를 가지고 있을 수 있음. 


*MIPS 명령어는 워드 단위로 정렬되므로 jal 명령어는 오른쪽 두 비트 사용 안함. 실제 주소를 생각할것

<로더>
목적 프로그램을 메인 메모리에 적재 후 실행할 수 있게 하는 시스템 프로그램
실행 파일 헤더 읽기-텍스트&데이터 세그먼트 크기 알아내기
텍스트, 데이터가 들어갈 주소공간 확보
실행파일 명령어, 데이터를 메모리에 복사
주 프로그램에 전달할 인수가 있으면 스택에 복사
레지스터 초기화 & 스택 포인터는 사용가능한 첫 주소를 가리키게 함
기동 루틴(start0up routine)으로 점프. 인수를 인수 레지스터에 넣고 프로그램 주 루틴을 호출. 주 프록램에서 기동루틴으로 복귀시 exit 시스템 호출을 사용해 프로그램 종료.
<동적 링크 라이브러리>
정적 접근 방법 단점
-라이브러리 루틴이 실행코드 일부가 됨 … 신판 라이브러리를 못씀.
-한 번이라도 호출되는 라이브러리는 모든 루틴을 다 적재해야함.(실제로 실행되지 않더라도)

-> 동적 링크 라이브러리(dynamically linked library, DLC)가 등장한 이유
: 실행시에 프로그램과 링크되는 라이브러리 루틴
-적절 라이브러리를 찾고 모든 외부 참조를 갱신함. 

초기 DLC의 단점: 호출 가능성이 있는 모든 라이브러리 루틴을 링크함. 
지연(lazy) 프로시저 링키지형의 DLC가 개발됨. (모든 루틴 호출 후 링크)

간접접근(indirection) 기법: 전역 루틴 하나당 더미루틴이 있고 더미 엔트리에는 간접 점프가 하나씩 있음.  더미 엔트리는 원하는 라이브러리 루틴을 표시하기 위해 점프하는 코드를 가리킴. 

DLL: 처음에만 루틴 호출하고 다음부터는 간접 점프 하나만으로 가능. 오늘날 UNIX에서 실행할 떄 얘가 디폴트임.


<자바 프로그램 실행>
: 실행시간 단축을 겨냥한 실행 (x)


실행시간은 느리더라도 어느 컴퓨터에나 안전하게 실행시킬 수 있게 하자(o)

자바 바이트코드 명령어 집합으로 일단 컴파일함. JVM(Java virtual Machine)이라 불리는 소프트웨어 인터프리터가 자바 바이트코드를 실행함.


인터프리터 장점: 이식성 / 단점: 낮은 성능 

JIT(Just In Time( 컴파일러: 이식성도 성능도 좋게 하기 위한 컴파일러. 실행중인 프로그램의 특성을 파악해 많이 사용되는 메소드를 찾아내 기계어로 컴파일함. 



2.13 종합: C 정렬 프로그램
두가지 C 프로시저의 MIPS 코드를 만드는 연습을 하기 
배열 원소 2개를 맞바꾸기
배열 원소를 정렬하기 

<프로시저>
swap. 메모리 내의 두 값을 단순히 맞바꾸기
프로그램변수에 레지스터를 할당하기
프로시저 본체에 해당하는 코드를 생성하기 
프로시저 호출 후의 레지스터 내용을 호출 전과 같도록 만든다



<프로시저 swap의 레지스터 할당>
인수 전달에는 an, 이때 v,k 두 인수는 $a0, $a1에 할당됨. 

<프로시저 swap 본체 프로그램>
tmp=v[k];
v[k]=v[k+1];
v[k+1]=temp;

바이트 주소를 사용하므로 각 워드는 실제로 4바이트씩 떨어져있음. 인덱스 k를 주소에 더하기 전에 4를 곱해야 함.(워드 주소는 1이 아니라 4씩 차이남)

swap 호출 전 후 레지스터 값 같게 유지하기(말단이라 지금은 별도 할일 없음)


<완성된 프로시저 swap>
프로시저 레이블, 복귀 점프만 추가하면 전체 루틴 완성



<프로시저 sort>
버블 정렬(교환 정렬) 방법으로 정수 배열을 정렬하기 

<프로시저 sort의 레지스터 할당>
두 인수 v, n을 인수 레지스터 $a0, $a1에 넣고 변수 i, j는 각각 레지스터 $s0, $s1을 할당함.

<프로시저 sort의 본체 프로그램>
중첩된 for순환문 2개, 프로시저 swap을 호출하는 부분으로 구성됨



for (i=0; i<n; i+=1){ 번역하기
for: 초기화, 반복조건 검사, 순환 제어 변수 증가 
move $s0, $zero # i=0      // 초기화
addi $s0, $s1, 1 #i+=1   // 값 증가

순환이 종료되는가 아닌가를 검사하기 위한 분기

j forltst #jump to test of outer loop 
exitl: 

첫번째 for 순환문의 형태



두번째 순환문 번역

for (j=i-1; j>=0 && v[j] > v[j+1]; j-=1){ 
addi $a1, $s0, -1   #j=i-1 초기화 부분
addi $s1, $s1, -1 #j-=1   // j값 감소

반복 조건 검사 (하나라도 거짓이면 빠져나옴)


시행되면 두번쨰 검사 생략. v[i]<=v[j+1]이면 순환문에서 빠져나옴. 먼저 j에 4를 곱해서 v에 시작주소에 더하기

이 주소를 이용해 v[j]를 읽기

다음 원소의 주소는 $t2에 4를 더해서 v[j+1]을 읽기

반복 조건 검사

마지막 명령: 내부 순환문 조건 검사로 점프

두번쨰 for순환문 종합



<프로시저 호출>
swap(v,j); 
호출 간단함. jal swap


<인수 전달>
sort, swap 프로시저가 인수전달을 위해 똑같은 레지스터를 사용해야히므로 인수 전달 방식이 문제
sort의 인수를 다른 레지스터에 복사해서 swap을 호출할 때 $a0, $a1을 사용할 수 있게 할 수 있음
복사후 전달

<프로시저 호출 전과 후의 레지스터 내용을 같게 유지하기>
레지스터 내용을 저장했다가 복구하는 프로그램. sort 자신도 호출된 입장이므로 $ra의 복귀 주소를 저장해야함. 이때 $s0, $s1, $s2, $s3등에 저장해야함.
sort 프로시저의 앞부분을 이럼.

프로시저 끝부분: 위 각 명령어 역 명령어에 jr 명령 추가


<완성된 프로시저 dort>
주의: for 순환문 레지스터 $a0, $a1에 대한 참조가  $s2, $s3로 바뀌었음. 
*프로시저 확장(procedure dure inlining) : 인수전달하고 jal 명령으로 호출하는 대신 swap을 호출하는 부분에 컴파일러가 swap 프로시저 본체 코드를 복사하는 것. 확장 기법을 적용해 명령어 4개 줄이기 가능. 



-최적화 컴파일러가 정렬 프로그램의 성능, 컴파일 시간, 클럭 사이클, 명령어 개수, CPI 등에 미치는 영향
CPI: 최적화 x 코드가 가장 좋음. 명령어 개수는 O1이 가장 적음. 가장 빠른 것은 O3. 
-> 프로그램 성능 척도는 실행 시간.

4번째 열: 버블 정렬에서 최적화되지 않은 c 프로그램이 인터프리트된 자바 코드보다 8.3배 빠름. JIT 컴파일러 사용시 -> 자바 프로그램이 최적화 x c프로그램보다 2.1배 빠르고 최적화된 c코드보다1.13배 정도 느림. 

5번째 열: 퀵 정렬 성능 비율이 버블 정렬과 다름- 실행시 컴파일 추가시간 상쇄하기엔 실행시간이 너무 짧음

마지막 열: 알고리즘 영향. 알고리즘에 따라 천배까지도 성능 차이가 남.

*인수 저장 필요시 사용하도록 MIPS 컴파일러는 항상 스택에 여유 공간을 확보해둠. 




2.14 배열과 포인터
한 프로시저는 배열인덱스, 다른 프로시저는 포인터를 이용할 때.

<배열을 사용한 clea>
(링키지 코드 무시하고 순환문 본체만 보기 일단), array, size는 레지스터 $a0, $a1에서 찾을 수 있고 변수 i는 $t0에 할당되었다고 가정.






-배열값을 모두 0으로 만드는 두  C 프로시저 

for 순환문의 첫부분: i의 초기화
move $t0, $zero    #i=0 (register $t0=0)
array[i]를 0으로 하려면 array[i]의 주소를 구해야함. i*4로 바이트 주소 계산을 시작하기
loop1; sll $t1, $t0, 2 # $t1=i*4
배열 시작 주소는 레지스터에 있으므로 add 명령어를 이용해 시작주소를 인덱스에 더함.

add $t2, $a0, $t1  #$t2=address of array[i]

마지막으로 해당 주소에 0을 저장하기
sw $zero, 0($t2) #array[i]=0
이 명령어가 순환문 본체의 끝이므로 다음은 i를 증가시키기
addi $t0, $t0, 1 # i=i+1
q
반복 검사는 i가 size보다 작은지 비교하는 것

배열 인덱스를 이용해 배열을 0으로 만드는 MIPS 코드 완성본


<포인터를 사용한 clear>
array, size를 레지스터 $s0, $a1에, 변수 p를 레지스터 $t0에 할당함. 두번째 프로시저는 포인터 p에 배열 첫번째 원소의 주소를 넣는 것으로 시작함.

move $t0, $a0  #p=address of array[0]
다음 코드 for 순환 본체, p가 가리키는 메모리에 0을 넣는 단순한 일임.
loop2: sw $zero, 0($t0) #Memory[p]=0

순환 증가. p가 다음 워드를 가리록 하기
addi $t0, $t0, 4  #p=p+4
C에서 포인터를 하나 증가시키는 것은 포인터를 다음 원소로 옮긴다는 뜻임. 
p는 정수 포인터, 정수는 4바이트이므로 컴파일러는 p를 4 증가시킴.

반복검사. array 마지막 원소 주소 계산 
sll $t1, $a1, 2 #$t1=size * 4
array 시작 주소에 더해 array의 마지막 워드 다음 주소를 구하기
add $t2, $a0, $t1 #$t2=address of array[size]
반복검사: p가 array의 마지막 원소 주소보다 작은가 검사


포인터를 이용해 배열값을 0으로 만드는 프로그램 완성


<두 프로그램 비교>

왼 프로그램은 순환문 내에서 덧셈, 곱셈 필요
오 프로그램은 매 반복마다 실행되는 명령어를 6개에서 4개로 줄임. 
-> 강도 감소, 유도 변수 제거


2.15 


2.16 실례: ARMv7(32비트명령어)
ARM (Advanced RISC Machine) : 임베디드용으로 가장 인기있는 명령어 집합 구조 (MIPS보다 레지스터는 더 적고 주소지정 방식은 더 많음)

<주소지정 방식>
-상수 0을 갖는 레지스터 X , 9개 주소지정(MIPS는 3개) 방식을 가짐. 

<비교 및 조건부 분기>
조건부 분기 여부 판단: MIPS는 레지스터값, ARM은 상태워드 - 4개 조건 코드 negative, zero, carry, overflow 비트를 사용함. 

CMP: 한 피연산자에서 다른 피연산자를 빼고 차이에 따라 조건 코드를 설정
CMN(compare negative): 한 피연산자에 다른 피연산자를 더해서 그 결과로 조건 코드를 설정함
TST: 두 피연산자에 논리적 AND 연산을 수행해서 overflow를 제외한 모든 조건 코드를 설정하게됨
TEQ: 두 피연산자에 XOR 연산. 나머지 조건코드 설정
-> 모든 명령어가 조건부로 실행됨.


<ARM 고유 특징>
-MIPS $zero로 할 수 있는 연산 수행가능한 별도 op코드 가짐. 다중 워드 산술도 지원함. 
-수치 필드 처리 과정이 복잡함. 
하위 8비트 앞에 0 24개 붙여 32비트로 만들고 왼쪽 4비트에 2 곱한 값 해당되는 비트만큼 오른쪽 회전. 


자리이동 선택사항: shift left logical, shift right logical, shift right arithmetic, rotate right
(모든 산술, 논리 연산의 두번째 레지스터는 자리이동 선택사항- 연산 전 자리이동 할지말지-을 가짐)

레지스터 여러개 저장 명령어 in ARM: block loads, block stores
-프로시저 진입, 복귀시 레지스터 저장 및 복원, 이때 코드의 크기를 줄여주며 메모리 복사까지 가능.





2.17 실례: ARMv8(64비트) 명령어
문제: 명령어 집합의 메모리 주소가 너무 작았음. (주소 비트가 너무 작음)
-> 완전히 뜯어고쳐 새로운 프로세서를 만듦 v7과 v8은 이름만 비슷함
-모든 명령어 조건부 실행 필드 삭제, 수치 필드를 단순 12비트 상수로 바꿈, 다중 적재-다중 저장 명령어 삭제, pc를 특수 레지스터로 만듦
-범용 레지스터 개수 32개로 증가, 항상 0인 레지스터를 두었음, 워드 크기에 대해 주소가 지정됨, 나눗셈 명령어 , 분기 명령어 추가




2.18. 실례: RISC-V 명령어
: RISC-V International 기구에서 관리하는 개방형 구조(오픈 명령어)
<RISC-V와 MIPS의 공통 특징>
-명령어 길이가 32비트임, 32개의 범용 레지스터 길이를 가졌고 하나는 항상 0임
-메모리 접근은 적재/저장 명령어로만 가능
-다중 레지스터에 적재 및 저장하는 명령어가 없음. 레지스터가 0이면 분기/0이 아니면 분기 명령어를 가짐 , 주소 지정 방식이 모든 데이터 크기에 적용됨.
<차이점>
같다 다르다 외의 다른 조건을 가진 조건부 분기가 있느냐 없느냐(MIPS는 있음)



2.19 실례: x86 명령어
목적: 프로그램이 실행하는 명령어의 개수를 줄이기
-> 근데 그러면 간결성이 줄어듦(클럭 사이클 개수가 많아지고 사이클 시간이 길어지기 때문)

<Intel x86의 진화>
1978: 범용 레지스터(general purpose register, GPR) 구조가 아닌 Intel 8086 발표
1980: Intel 8087-부동 소수점 명령어 추가 (부동 소수점 코프로세서 발표)
1982, 1985: 주소 지정 방식과 명령어 추가, 주소 공간 확장…
1989~1995: 성능 개선에 힘씀. 멀티프로세싱 지원 기능, 조건부 move 명령어 추가
1997: SIMD(single instruction multiple data) 방식으로 작동하는 MMX(Multimedia extention) 기능 추가 계획 발표, 57개 명령어 추가가
1999: SSE(streaming SIMD extention)라는 명령어 70개 추가, 128비트 레지스터 8개 추가, 단일 정밀도 부동 소수점 데이터형 추가 
2001: SSE2 명령어 144개 추가, 2배 정밀도 연산 추가 (double precision)
2003: 모든 레지스터를 64비트로 확장, 레지스터 16개로 증가, 새 주소지정방식(long mode) 추가, 새로운 접두사(prefix) 추가…
2004: 원자적 128비트 비교 및 교환(atomic compare and swap) 명령어 추가, EM64T(Extended Memory 64 Technology) 라는 이름을 붙임
2006: SSE4 확장 -54개 새 명령어 발표-구조체 배열 내적, 부호확장, 개체수세기 등…
2007: SSE5, 피연산자가 3개인 명령어 등 발표
2011: SSE 레지스터를 256비트로 확장 고급 벡터 확장(advanced vector extention) 발표
2015: 레지스터 연산을 512비트로 확장, 명령어 재정의, AVX-512 발표

클라우드 부분에서 x86은 가장 많이 사용되는 기술임. 이해도 안가고 이상한 기술이긴하지만


<x86레지스터와 데이터 주소 지정 방식>

범용 레지스터(general purpose register, GPR): 16비트 레지스터를 32비트로 확장, 레지스터 이름 앞에 E를 붙임. 
<x86/ ARM, MIPS과의 차이점>
x86에서 피연산자 하나는 근원지이며 동시에 목적지임. 불편함.
피연산자 중 하나가 메모리에 있을 수 있음 MIPS, ARM과 달리 모든 명령어가 메모리 피연산자를 사용 가능. 
변위(displacement) 주소: 8비트, 32비트 두 종류. 명령어 내에 두가지 크기의 주소를 둘 수 있음. 8비트와 32비트.




<x86의 정수 연산>
8086: 8비트(바이트), 16비트(워드) 지원.
80386: 32비트 주소, 32비트 데이터(더블 워드) 추가. 
디폴트 데이터 크기: 코드 세그먼트 레지스터 비트 하나를 이용하여 설정됨. 디폴트 데이터가 아니면 명령어에 8비트짜리 접두사를 붙여 다른 크기 데이터를 사용함함

원래의 세가지 접두사
디폴트가 아닌 다른 세그먼트 레지스터 사용
동기화 지원을 위한 버스 잠금 
ECX 레지스터가 0이 될 때까지 명령어 반복실행을 지시
근데 디폴트 크기가 아닌 주소를 사용하기 위해 접두사 하나를 추가함

<x86의 정수 명령>
move, push, pop을 포함하는 데이터 전송 명령
검사, 정수/십진수 연산을 포함하는 산술 및 논리 명령
조건부 분기, 무조건 점프, call, return 등을 포함하는 제어 흐름 명령
문자열 이동 및 문자열 비교 등을 포함하는 문자열 명령

x86의 조건부 분기는 조건 코드(또는 플래그)에 의해 결정됨. 





<x86의 명령어 인코딩>
80386 기준.
명령어 길이는 1바이트 ~15바이트까지 매우 다양함(쌰갈)

opcode: 피연산자 크기가 8비트인지 32비트인지 표시하는 비트가 포함됨.(가끔 주소 지정 방식, 레지스터 필드가 포함된 경우도 있음) 레지스터 =레지스터 op 상수인 경우. 



postbyte: 메모리에 접근하는 명령어에서 많이 사용됨. 베이스 + 스케일링 인덱스 주소지정 방식은 “sc, base”라는 두번째 postbyte를 사용함


<결론>
이런 거지같이 복잡한 것이 가장 많이 쓰이는 명령어 집합인 것이 통탄스럽다
개인 휴대용 기기에는 그닥 쓰이지 않음



2.20 더 빠르게: C로 작성한 행렬 곱셈 프로그램
DGEMM(Double Precision Matrix Multiply): C로 작성된 행렬 곱셈 프로그램

성능향상 원인: 인터프리터 대신 컴파일러를 사용, C의 타입 선언 -> 컴파일러가 더 효과적인 코드를 생성하게 함




2.21 오류 및 함정
오류: 강력한 명령어를 사용하면 성능이 좋아진다, 최고 성능을 얻기 위해 어셈블리 언어로 프로그램 작성하기, 상업용 프로그램의 이진 호환성이 중요하다는 것은 성공적인 명령어 집합은 변하지 않는다는 것을 의미한다, 바이트 주소를 사용하는 컴퓨터에서 인접 워드 간의 주소 차이가 1이 아니라는 사실을 잊는 것 
함정: 자동 변수가 정의된 프로시저 외부에서 자동 변수에 대한 포인터를 사용하기(메모리 종료시 다른 용도로 재 사용될 위험이 존재함)



2.22 결론
내장 프로그램 컴퓨터의 두 가지 기본 원리 1) 같은 형태의 명령어를 사용하는 것 2) 변경가능한 메모리에 프로그램을 저장하는 것

<설계원칙 3가지>
간단하게 하기 위해서는 규칙적인 것으로
작은것이 더 빠르다
좋은 설계에는 적당한 절충이 필요하다

<MIPS의 각 명령어 종류를 상위수준 언어 구조와 연관 짓기>
-산술 명령어 -> 치환문의 연산에 해당
-데이터 전송 명령어 -> 배열, 구조체 자료구조
-조건부 분기: if문과 순환문
-무조건 점프 : 프로시저 호출, 복귀, cas/switch문




2.24 자습
다음 이진수가 주어졌다. 
00000001010010110100100000100000
16진수로 : 0x014B5040
부호 없는 정수로 가정했을때 10진수값: 21788864
부호있는 정수로 가정했을때 10진수값: 21788864
명령어로 가정한다면 어셈블리 언어로는 : 
opcode = 000000 → R-형식
rs = 01010₂ = 10 → $t2
rt = 01011₂ = 11 → $t3
rd = 01010₂ = 10 → $t2
shamt = 00000
funct = 100000 → add
답: add $t2, $t2, $t3
